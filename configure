#!/bin/sh
set -e

# Defaults
[ -z "$CC" ] && CC="cc"
[ -z "$CFLAGS" ] && CFLAGS="--std=c99 -Werror -Wall -Wextra -Wpedantic -O2 -D_DEFAULT_SOURCE"
[ -z "$LDFLAGS" ] && LDFLAGS=""

includes="include/noded.h include/ast.h include/bytecode.h test/vm-framework.h"
debug_flags=false

bins () {
    mktarget src/alloc src/ast src/bytecode src/compiler src/dict \
             src/err src/noded src/parser src/scanner src/token src/vm
    mktool disasm src/bytecode
    mktool compile src/alloc src/ast src/compiler src/dict src/err \
           src/parser src/scanner src/token
    mktest test-vm src/alloc src/bytecode src/vm test/vm-framework
    mktest test-compiler src/alloc src/ast src/bytecode src/compiler \
           src/dict src/err src/parser src/scanner src/token src/vm \
           test/vm-framework
}

for i in "$@"; do
    case $1 in
        CC=*)
            CC="${i#*=}"
            ;;
        CFLAGS=*)
            CFLAGS="${i#*=}"
            ;;
        LDFLAGS=*)
            LDFLAGS="${i#*=}"
            ;;
        --debug)
            debug_flags=true
            ;;
        --help | -h)
            cat <<EOF
Noded programming language configuration program.

Variables that will be exported to the makefile:

    CC                 The C compiler to be used to compile noded.
                       (default: cc)
    CFLAGS             The C flags.
                       (default: --std=c99 -Werror -Wall -Wextra -Wpedantic -D_DEFAULT_SOURCE)
    LDFLAGS            The C link flags.
                       (default: none)
Available options:
    --debug            Append debug flags to the compiler

    --help             Shows this help.
EOF
            exit 0
            ;;
        *)
            echo "Unknown option: $i"
            exit 1
            ;;
    esac
done

if $debug_flags; then
    CFLAGS="$CFLAGS -g -O0"
else
    CFLAGS="$CFLAGS -DNDEBUG"
fi

echo "Prefix: $PREFIX"
echo "CC=$CC"
echo "CFLAGS=$CFLAGS"
echo "LDFLAGS=$LDFLAGS"
# Create the main Makefile
sed "
s|@@CC@@|$CC|g;
s|@@CFLAGS@@|$CFLAGS|g;
s|@@LDFLAGS@@|$LDFLAGS|g;
s|@@INCLUDES@@|$includes|g
" < Makefile.in > Makefile

src () {
    echo "$1.c"
}

obj () {
    echo "build/${1#*/}.o"
}

objs () {
    for obj in "$@"; do
        echo `obj $obj`
    done
}

inline () {
    tr '\n' ' '
}

# OBJECTS = ...
mktarget () {
    objs "$@"
}

mktool () {
    name="$1"
    shift
    objs "tools/$1" "$@"
}

mktest () {
    name="$1"
    shift
    objs "test/$1" "$@"
}

echo "OBJECTS = `bins | sort -u | inline`" > build.make

# TOOLS = ...
mktarget () { true; }
mktool () {
    echo "$1"
}
mktest () { true; }

echo "TOOLS = `bins | inline`" >> build.make

# TESTS = ...
mktool () { true; }
mktest () {
    echo "$1"
}

echo "TESTS = `bins | inline`" >> build.make
echo >> build.make

# tools: ...
echo 'tools: $(TOOLS)' >> build.make
echo >> build.make

# test: ...
echo 'test: $(TESTS)' >> build.make
mktest () {
    printf '\t./%s\n' "$1"
}
bins >> build.make
echo >> build.make

# Building binaries
binary () {
    printf '%s: %s\n' "$1" "$2"
    printf '\t$(CC) $(LDFLAGS) -o $@ %s\n' "$2"
    echo
}

mktarget () {
    binary '$(TARGET)' "`objs "$@" | inline`"
}

mktool () {
    name="$1"
    shift
    binary "$name" "`objs "tools/$name" "$@" | inline`"
}

mktest () {
    name="$1"
    shift
    binary "$name" "`objs "test/$name" "$@" | inline`"
}

bins >> build.make

# Building object files
mktarget () {
    echo "$@" | tr ' ' '\n'
}

mktool () {
    name="$1"
    shift
    echo "tools/$name" "$@" | tr ' ' '\n'
}

mktest () {
    name="$1"
    shift
    echo "test/$name" "$@" | tr ' ' '\n'
}

for obj in `bins | sort -u | inline`; do
    printf '%s: %s $(INCLUDES)\n' `obj $obj` `src $obj`
    printf '\t$(CC) $(CFLAGS) -o $@ -c %s\n' `src $obj`
done >> build.make

exit 0
